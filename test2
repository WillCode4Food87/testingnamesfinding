[CmdletBinding()]
param(
    [Parameter(Mandatory = $true)]
    [string]$RootPath,

    [string]$OutputCsv = $(Join-Path -Path (Get-Location) -ChildPath 'view_script_imports.csv'),

    [int]$MaxPreviewLength = 200
)

if (-not (Test-Path -LiteralPath $RootPath)) {
    throw "RootPath '$RootPath' does not exist."
}

# Target extensions under Views
$targetExtensions = @('.aspx', '.ascx', '.cshtml', '.master', '.html')

# -------------------------------------------------------------------
# Helper: infer controller name from Views/<Controller>/...
# -------------------------------------------------------------------
function Get-ControllerName {
    param(
        [Parameter(Mandatory = $true)]
        [string]$FilePath
    )

    $parts = $FilePath -split '[\\/]+'
    $viewsIndex = -1
    for ($i = 0; $i -lt $parts.Length; $i++) {
        if ($parts[$i].Equals('Views', [System.StringComparison]::InvariantCultureIgnoreCase)) {
            $viewsIndex = $i
            break
        }
    }

    if ($viewsIndex -ge 0 -and ($viewsIndex + 1) -lt $parts.Length) {
        return $parts[$viewsIndex + 1]
    }

    return 'N/A'
}

# -------------------------------------------------------------------
# Regexes for script imports
# -------------------------------------------------------------------
# 1) HTML script tags: <script src="..."></script>
$scriptTagRegex = '<script\b[^>]*\bsrc\s*=\s*["'']([^"'']+)["''][^>]*>' 

# 2) Scripts.Render(...) bundle helpers (Razor or WebForms)
#    We first match Scripts.Render(<args>) then pull each quoted arg inside.
$scriptsRenderCallRegex = 'Scripts\.Render\s*\(([^)]*)\)'
$scriptsRenderArgRegex  = '["'']([^"'']+)["'']'   # each quoted bundle path

# -------------------------------------------------------------------
# Collect candidate files (Views + allowed extensions)
# -------------------------------------------------------------------
$files = Get-ChildItem -Path $RootPath -Recurse -File |
    Where-Object {
        ($targetExtensions -contains $_.Extension.ToLower()) -and
        ($_.FullName -notmatch '([\\/])bin([\\/])' -and $_.FullName -notmatch '([\\/])obj([\\/])') -and
        ($_.FullName -match '([\\/])Views([\\/])')
    }

if (-not $files) {
    Write-Host "No view files found under $RootPath." -ForegroundColor Yellow
}

$results = New-Object System.Collections.Generic.List[object]

foreach ($file in $files) {
    $controllerName = Get-ControllerName -FilePath $file.FullName
    $lines = Get-Content -LiteralPath $file.FullName

    for ($i = 0; $i -lt $lines.Count; $i++) {
        $line       = $lines[$i]
        $lineNumber = $i + 1

        if ([string]::IsNullOrWhiteSpace($line)) { continue }

        $preview = $line.Trim()
        if ($preview.Length -gt $MaxPreviewLength) {
            $preview = $preview.Substring(0, $MaxPreviewLength)
        }

        # ---------------------------------------------
        # 1) Script tags with src="..."
        # ---------------------------------------------
        $tagMatches = [System.Text.RegularExpressions.Regex]::Matches(
            $line,
            $scriptTagRegex,
            [System.Text.RegularExpressions.RegexOptions]::IgnoreCase
        )

        foreach ($m in $tagMatches) {
            if (-not $m.Success) { continue }

            $src = $m.Groups[1].Value
            if ([string]::IsNullOrWhiteSpace($src)) { continue }

            $results.Add(
                [pscustomobject]@{
                    ControllerName = $controllerName
                    FilePath       = $file.FullName
                    FileName       = $file.Name
                    Extension      = $file.Extension
                    MatchValue     = $src
                    Preview        = $preview
                    LineNumber     = $lineNumber
                }
            ) | Out-Null
        }

        # ---------------------------------------------
        # 2) Scripts.Render("...") helpers
        #    Example: @Scripts.Render("~/bundles/jquery", "~/bundles/bootstrap")
        # ---------------------------------------------
        $renderMatches = [System.Text.RegularExpressions.Regex]::Matches(
            $line,
            $scriptsRenderCallRegex,
            [System.Text.RegularExpressions.RegexOptions]::IgnoreCase
        )

        foreach ($rm in $renderMatches) {
            if (-not $rm.Success) { continue }

            $argsText = $rm.Groups[1].Value
            if ([string]::IsNullOrWhiteSpace($argsText)) { continue }

            $argMatches = [System.Text.RegularExpressions.Regex]::Matches(
                $argsText,
                $scriptsRenderArgRegex,
                [System.Text.RegularExpressions.RegexOptions]::IgnoreCase
            )

            foreach ($am in $argMatches) {
                if (-not $am.Success) { continue }

                $bundlePath = $am.Groups[1].Value
                if ([string]::IsNullOrWhiteSpace($bundlePath)) { continue }

                $results.Add(
                    [pscustomobject]@{
                        ControllerName = $controllerName
                        FilePath       = $file.FullName
                        FileName       = $file.Name
                        Extension      = $file.Extension
                        MatchValue     = $bundlePath
                        Preview        = $preview
                        LineNumber     = $lineNumber
                    }
                ) | Out-Null
            }
        }
    }
}

$results |
    Select-Object ControllerName, FilePath, FileName, Extension, MatchValue, Preview, LineNumber |
    Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8

Write-Host "Scanned $($files.Count) view files. Found $($results.Count) script imports. CSV written to: $OutputCsv"
